<html>
<head><title>Ruby-DOOM</title></head>
<body>

<h3><center>Ruby-DOOM</center></h3>

<a name="#top"/>
<p>If you want to generate a DOOM map, you need to use a level editor and manually create the map, either from scratch, or from a template.  Although this works well for most map creation scenarios, it would be nifty if maps could be generated programmatically.  This would allow maps to be generated for <a href="http://cougaar.org/">Cougaar</a> agent community visualization, or <a href="http://pmd.sf.net/">PMD</a> problem visualization, or from a floor plan. 

<p>Here's the <a href="http://rubyforge.org/projects/ruby-doom/">project page</a> and <a href="http://rubyforge.org/cgi-bin/viewcvs/cgi/viewcvs.cgi/ruby-doom/src/ruby/?cvsroot=ruby-doom#dirlist">the code and unit tests</a>.

<p>Here's an example of what I'd like to be able to do:
<table>
<tr>
<td>
<pre>
level = Level.new(10,10)
level.add(Sector.new(1,1,8,8))
level.spawn_point(3,3)
m = Map.new(level)
m.write_to_file("simple.wad")
</pre>
</td>
<td width=200 align=center>
<====>
</td>
<td>
<img src="samplemap.png"/>
</td>
</tr>
</table>

<hr>
<br><a href="#userdocs">User documentation</a>
<br><a href="#wad">WAD file structure</a>
<hr>
<a name="userdocs"></a><a href="#top">Top</a>
<p>Here's a sample run from the current version of <code>doom.rb</code>:
<pre>
[tom@rubyforge ruby]$ ./doom.rb -v
Reading WAD into memory
Done reading, building the object model
Created MAP01
Created THINGS
Created LINEDEFS
Created SIDEDEFS
Created VERTEXES
Created SEGS
Created SSECTORS
Created NODES
Created SECTORS
Created REJECT
Created BLOCKMAP
Object model built
The file ../../test_wads/simple.wad is a 900 byte PWAD
It's got 11 lumps, the directory started at byte 724
MAP01 (0 bytes)
THINGS (10 bytes)
 - Player 1 at (224,-416) facing east
LINEDEFS (112 bytes)
 - Linedef from 0 to 1; attribute flag is 1; special fx is 0; tag is 0; right sidedef is 0; left sidedef is -1
 - Linedef from 1 to 2; attribute flag is 1; special fx is 0; tag is 0; right sidedef is 1; left sidedef is -1
 - Linedef from 2 to 3; attribute flag is 1; special fx is 0; tag is 0; right sidedef is 2; left sidedef is -1
 - Linedef from 3 to 0; attribute flag is 1; special fx is 0; tag is 0; right sidedef is 3; left sidedef is -1
 - Linedef from 4 to 5; attribute flag is 1; special fx is 0; tag is 0; right sidedef is 4; left sidedef is -1
 - Linedef from 5 to 6; attribute flag is 1; special fx is 0; tag is 0; right sidedef is 5; left sidedef is -1
 - Linedef from 6 to 7; attribute flag is 1; special fx is 0; tag is 0; right sidedef is 6; left sidedef is -1
 - Linedef from 7 to 4; attribute flag is 1; special fx is 0; tag is 0; right sidedef is 7; left sidedef is -1
SIDEDEFS (240 bytes)
 -  Sidedef for sector 0
 -  Sidedef for sector 0
 -  Sidedef for sector 0
 -  Sidedef for sector 0
 -  Sidedef for sector 1
 -  Sidedef for sector 1
 -  Sidedef for sector 1
 -  Sidedef for sector 1
VERTEXES (32 bytes)
 -  Vertex at (64,-320)
 -  Vertex at (384,-320)
 -  Vertex at (384,-512)
 -  Vertex at (64,-512)
 -  Vertex at (640,-320)
 -  Vertex at (896,-320)
 -  Vertex at (896,-512)
 -  Vertex at (640,-512)
SEGS (96 bytes)
SSECTORS (8 bytes)
NODES (28 bytes)
SECTORS (52 bytes)
 -  Sector floor/ceiling heights 0/128; floor/ceiling textures FLAT14/
 -  Sector floor/ceiling heights 0/128; floor/ceiling textures FLAT14/
REJECT (1 bytes)
BLOCKMAP (132 bytes)
Writing WAD
Done
</pre>

<hr>
<a name="wad"></a><a href="#top">Top</a>
<p>I'll try to document the wad file structure as I go.  Props go out to the many folks out there who have figured out this stuff before I did.  Hopefully I can summarize some of the important points here.
<p><b>Header</b> - a 12 byte sequence.  <font color="blue">80, 87, 65, 68, 11, 0, 0, 0, 212, 2, 0, 0, 0</font>
<ul>
<li>Bytes 0-3: WAD type - either PWAD or IWAD (characters).  <font color="blue">80, 87, 65, 68</font>
<li>Bytes 4-7: Number of lumps (<a href="#long">long integer</a>). <font color="blue">11, 0, 0, 0</font>
<li>Bytes 8-12: File offset to the beginning of the directory (long integer). <font color="blue">212, 2, 0, 0, 0</font>
</ul>
<p><b>Directory entries</b> - a series of 16 byte sequences.  <font color="blue">13, 0, 0, 0, 10, 0, 0, 0, 84, 72, 73, 78, 71, 83, 0, 0</font>
<ul>
<li>Bytes 0-3: The file offset to the start of the lump (long integer).  <font color="blue">13, 0, 0, 0</font>
<li>Bytes 4-7: Size of the lump (long integer).  <font color="blue">10, 0, 0, 0</font>
<li>Bytes 8-15: The name of the lump padded with zeros (characters).  <font color="blue">84, 72, 73, 78, 71, 83, 0, 0</font>
</ul>
<p><b>Lumps</b> - a bunch of different kinds of data of variable length.
<ul>
<li>THINGS - 10 bytes 
<ul>
<li>Bytes 0-2: Location (x) (short) 
<li>Bytes 2-4: Location (y) (short)
<li>Bytes 4-6: Facing angle (short)
<li>Bytes 6-8: Type ID (short)
<li>Bytes 8-10: Flags (short)
</ul>

<li>LINEDEFS - 12 bytes 
<ul>
<li>Bytes 0-2: Start VERTEX (short) 
<li>Bytes 2-4: End VERTEX (short)
<li>Bytes 4-6: Attributes (short)
<li>Bytes 6-8: Special effects type (short)
<li>Bytes 8-10: Tag (short)
<li>Bytes 10-12: Right SIDEDEF (short)
<li>Bytes 12-14: Left SIDEDEF (short)
</ul>

<li>SIDEDEFS - 30 bytes
<ul>
<li>Bytes 0-2: Texture x offset (short)
<li>Bytes 0-4: Texture y offset (short)
<li>Bytes 4-12: Upper texture name (8 byte string)
<li>Bytes 12-20: Lower texture name (8 byte string)
<li>Bytes 20-28: Middle texture name (8 byte string)
<li>Bytes 28-30: Sector id (short)
</ul>

<li>VERTEXES - 4 bytes
<ul>
<li>Bytes 0-2: x coordinate (short)
<li>Bytes 2-4: y coordinate (short)
</ul>

<li>SEGS (not parsed into object model)
<li>SSECTORS (not parsed into object model)
<li>NODES (not parsed into object model)

<li>SECTORS - 26 bytes
<ul>
<li>Bytes 0-2: Floor height (short)
<li>Bytes 2-4: Ceiling height (short)
<li>Bytes 4-12: Floor texture (8 byte string)
<li>Bytes 12-20: Ceiling texture (8 byte string)
<li>Bytes 20-22: Light level (short)
<li>Bytes 22-24: Special sector (short)
<li>Bytes 24-26: Tag (short)
</ul>

<li>REJECT (not parsed into object model)
<li>BLOCKMAP (not parsed into object model)
</ul>
<hr>
<ul>
<li><a name="long"/>All long integers are 32 bit unsigned longs in little-endian format (shorts are signed, 16 bits, little-endian as well).  So the byte sequence <font color="blue">212 2 0 0</font> is really <font color="blue">0 0 2 212</font> which translates to <font color="blue">724</font> decimal.  I'm using the following Ruby snippet to do this transformation:
<pre>
bytes.pack("C4").unpack("V")[0]
</pre>
<p>Also, I'm a bit of a dolt, so I had to do this to understand this byte packing order.  <font color="blue">0 0 2 212</font> converted to binary is <code>00000000 00000000 00000010 11001010</code>.  So the <code>1</code> is in the <code>512</code> place, so <code>512 + 212 = 724</code>.
<p>

<li>Some notes from a fella on Slashdot - the WAD file builder only needs to generate the THINGS, LINEDEFS, SIDEDEFS, VERTEXES, AND SECTORS.  Everything else is generated by a <a href="http://doombsp.sf.net/">BSP node builder</a>.
</ul>

</body>
<html>
